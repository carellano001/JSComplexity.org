;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var constants, form, formElement;

  constants = require('./constants');

  form = require('./form');

  formElement = document.getElementById(constants.ids.form);

  if (formElement) {
    form.initialise(formElement);
  }

}).call(this);

},{"./constants":2,"./form":3}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  module.exports = {
    ids: {
      form: 'source-form'
    },
    names: {
      eventBroker: 'jscomplexity'
    },
    events: {
      submit: 'submit',
      analyseSource: 'analyse-source'
    }
  };

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var constants, initialise, pubsub, serialiseForm;

  constants = require('./constants');

  pubsub = require('pub-sub');

  initialise = function(element) {
    var eventBroker;
    eventBroker = pubsub.getEventBroker(constants.names.eventBroker);
    return element.addEventListener(constants.events.submit, function(event) {
      eventBroker.publish(pubsub.createEvent({
        name: constants.events.analyseSource,
        data: serialiseForm(element)
      }));
      return event.preventDefault();
    });
  };

  serialiseForm = function(element) {
    var input, inputs, result, _i, _len;
    result = {};
    inputs = element.getElementsByTagName('input');
    for (_i = 0, _len = inputs.length; _i < _len; _i++) {
      input = inputs[_i];
      result[input.getAttribute('name')] = input.value;
    }
    return result;
  };

  module.exports = {
    initialise: initialise
  };

}).call(this);

},{"./constants":2,"pub-sub":5}],4:[function(require,module,exports){
/**
 * This module exports functions for checking types
 * and throwing exceptions.
 */

/*globals window, module */

(function () {
    'use strict';

    var functions = {
        verifyQuack: verifyQuack,
        quacksLike: quacksLike,
        verifyInstance: verifyInstance,
        isInstance: isInstance,
        verifyObject: verifyObject,
        isObject: isObject,
        verifyArray: verifyArray,
        isArray: isArray,
        verifyFunction: verifyFunction,
        isFunction: isFunction,
        verifyUnemptyString: verifyUnemptyString,
        isUnemptyString:isUnemptyString,
        verifyString: verifyString,
        isString: isString,
        verifyNumber: verifyNumber,
        isNumber: isNumber
    };

    if (module && module.exports) {
        module.exports = functions;
    } else {
        window.check = functions;
    }

    /**
     * Public function `verifyQuack`.
     *
     * Throws an exception if an object does not share
     * the properties of a second, archetypal object
     * (i.e. doesn't 'quack like a duck').
     *
     * @param thing {object}     The object to test.
     * @param duck {object}      The archetypal object,
     *                           or 'duck', that the test
     *                           is against.
     * @param [message] {string} An optional error message
     *                           to set on the thrown Error.
     */
    function verifyQuack (thing, duck, message) {
        if (quacksLike(thing, duck) === false) {
            throw new Error(message || 'Invalid type');
        }
    }

    /**
     * Public function `quacksLike`.
     *
     * Tests whether an object 'quacks like a duck'.
     * Returns `true` if the first argument has all of
     * the properties of the second, archetypal argument
     * (the 'duck'). Returns `false` otherwise. If either
     * argument is not an object, an exception is thrown.
     *
     * @param thing {object} The object to test.
     * @param duck {object}  The archetypal object, or
     *                       'duck', that the test is
     *                       against.
     */
    function quacksLike (thing, duck) {
        var property;

        verifyObject(thing);
        verifyObject(duck);

        for (property in duck) {
            if (duck.hasOwnProperty(property)) {
                if (thing.hasOwnProperty(property) === false) {
                    return false;
                }

                if (typeof thing[property] !== typeof duck[property]) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Public function `verifyInstance`.
     *
     * Throws an exception if an object is not an instance
     * of a prototype.
     *
     * @param thing {object}       The object to test.
     * @param prototype {function} The prototype that the
     *                             test is against.
     * @param [message] {string}   An optional error message
     *                             to set on the thrown Error.
     */
    function verifyInstance (thing, prototype, message) {
        if (isInstance(thing, prototype) === false) {
            throw new Error(message || 'Invalid type');
        }
    }

    /**
     * Public function `isInstance`.
     *
     * Returns `true` if an object is an instance of a prototype,
     * `false` otherwise.
     *
     * @param thing {object}       The object to test.
     * @param prototype {function} The prototype that the
     *                             test is against.
     */
    function isInstance (thing, prototype) {
        if (typeof thing === 'undefined' || thing === null) {
            return false;
        }

        if (isFunction(prototype) && thing instanceof prototype) {
            return true;
        }

        return false;
    }

    /**
     * Public function `verifyObject`.
     *
     * Throws an exception unless something is a non-null,
     * non-array object.
     *
     * @param thing              The thing to test.
     * @param [message] {string} An optional error message
     *                           to set on the thrown Error.
     */
    function verifyObject (thing, message) {
        if (isObject(thing) === false) {
            throw new Error(message || 'Invalid object');
        }
    }

    /**
     * Public function `isObject`.
     *
     * Returns `true` if something is a non-null, non-array
     * object, `false` otherwise.
     *
     * @param thing          The thing to test.
     */
    function isObject (thing) {
        if (typeof thing === 'object' && thing !== null && isArray(thing) === false) {
            return true;
        }

        return false;
    }

    /**
     * Public function `verifyArray`.
     *
     * Throws an exception unless something is an array.
     *
     * @param thing              The thing to test.
     * @param [message] {string} An optional error message
     *                           to set on the thrown Error.
     */
    function verifyArray (thing, message) {
        if (isArray(thing) === false) {
            throw new Error(message || 'Invalid array');
        }
    }

    /**
     * Public function `isArray`.
     *
     * Returns `true` something is an array, `false` otherwise.
     *
     * @param thing          The thing to test.
     */
    function isArray (thing) {
        if (Object.prototype.toString.call(thing) === '[object Array]') {
            return true;
        }

        return false;
    }

    /**
     * Public function `verifyFunction`.
     *
     * Throws an exception unless something is function.
     *
     * @param thing              The thing to test.
     * @param [message] {string} An optional error message
     *                           to set on the thrown Error.
     */
    function verifyFunction (thing, message) {
        if (isFunction(thing) === false) {
            throw new Error(message || 'Invalid function');
        }
    }

    /**
     * Public function `isFunction`.
     *
     * Returns `true` if something is function, `false` otherwise.
     *
     * @param thing          The thing to test.
     */
    function isFunction (thing) {
        if (typeof thing === 'function') {
            return true;
        }

        return false;
    }

    /**
     * Public function `verifyUnemptyString`.
     *
     * Throws an exception unless something is a non-empty string.
     *
     * @param thing              The thing to test.
     * @param [message] {string} An optional error message
     *                           to set on the thrown Error.
     */
    function verifyUnemptyString (thing, message) {
        if (isUnemptyString(thing) === false) {
            throw new Error(message || 'Invalid string');
        }
    }

    /**
     * Public function `isUnemptyString`.
     *
     * Returns `true` if something is a non-empty string, `false`
     * otherwise.
     *
     * @param thing          The thing to test.
     */
    function isUnemptyString (thing) {
        if (isString(thing) && thing !== '') {
            return true;
        }

        return false;
    }

    /**
     * Public function `verifyString`.
     *
     * Throws an exception unless something is a string.
     *
     * @param thing              The thing to test.
     * @param [message] {string} An optional error message
     *                           to set on the thrown Error.
     */
    function verifyString (thing, message) {
        if (isString(thing) === false) {
            throw new Error(message || 'Invalid string');
        }
    }

    /**
     * Public function `isString`.
     *
     * Returns `true` if something is a string, `false` otherwise.
     *
     * @param thing          The thing to test.
     */
    function isString (thing) {
        if (typeof thing === 'string') {
            return true;
        }

        return false;
    }

    /**
     * Public function `verifyNumber`.
     *
     * Throws an exception unless something is a number (also excluding NaN).
     *
     * @param thing              The thing to test.
     * @param [message] {string} An optional error message
     *                           to set on the thrown Error.
     */
    function verifyNumber (thing, message) {
        if (isNumber(thing) === false) {
            throw new Error(message || 'Invalid number');
        }
    }

    /**
     * Public function `isNumber`.
     *
     * Returns `true` if something a number other than NaN, `false` otherwise.
     *
     * @param thing          The thing to test.
     */
    function isNumber (thing) {
        if (isNaN(thing) === true) {
            return false;
        }

        if (typeof thing === 'number') {
            return true;
        }

        return false;
    }
}());


},{}],5:[function(require,module,exports){
/*globals require, define, module */

(function (globals) {
    'use strict';

    var check = require('check-types'),

    archetypalEvent = createEvent({ name: 'archetype' }),

    eventBrokers = {},

    functions = {
        createEvent: createEvent,
        getEventBroker: getEventBroker
    };

    exportFunctions();

    function createEvent (args) {
        var name, data, callback, self;

        check.verifyObject(args, 'Invalid arguments');

        name = args.name;
        data = args.data || {};
        callback = args.callback;

        check.verifyUnemptyString(name, 'Invalid name');
        if (typeof callback !== 'undefined') {
            check.verifyFunction(callback, 'Invalid callback');
        }

        self = {
            getName: getName,
            getData: getData,
            respond: respond
        };

        return self;

        function getName () {
            return name;
        }

        function getData () {
            return data;
        }

        function respond () {
            if (callback) {
                callback.apply(self, arguments);
            }
        }
    }

    function getEventBroker (id) {
        var subscriptions = {
            '*': []
        };

        check.verifyUnemptyString(id, 'Invalid id');

        if (typeof eventBrokers[id] === 'undefined') {
            eventBrokers[id] = {
                subscribe: subscribe,
                unsubscribe: unsubscribe,
                publish: publish
            };
        }

        return eventBrokers[id];

        function subscribe (args) {
            verifyArgs(args);
            addSubscription(args.name, args.callback);
        }

        function verifyArgs (args) {
            check.verifyObject(args, 'Invalid arguments');
            check.verifyUnemptyString(args.name, 'Invalid name');
            check.verifyFunction(args.callback, 'Invalid callback');
        }

        function addSubscription (eventName, callback) {
            if (typeof subscriptions[eventName] === 'undefined') {
                subscriptions[eventName] = [];
            }

            subscriptions[eventName].push(callback);
        }

        function unsubscribe (args) {
            verifyArgs(args);
            removeSubscription(args.name, args.callback);
        }

        function removeSubscription (eventName, callback) {
            var i, eventSubscriptions = subscriptions[eventName];

            if (check.isArray(eventSubscriptions) === false) {
                return;
            }

            for (i = 0; i < eventSubscriptions.length; i += 1) {
                if (eventSubscriptions[i] === callback) {
                    eventSubscriptions.splice(i, 1);
                    break;
                }
            }
        }

        function publish (event) {
            check.verifyQuack(event, archetypalEvent, 'Invalid event');

            notifySubscriptions(event, '*');
            notifySubscriptions(event, event.getName());
        }

        function notifySubscriptions (event, eventName) {
            var eventSubscriptions = subscriptions[eventName], i;

            if (check.isArray(eventSubscriptions)) {
                for (i = 0; i < eventSubscriptions.length; i += 1) {
                    eventSubscriptions[i](event);
                }
            }
        }
    }

    function exportFunctions () {
        if (typeof define === 'function' && define.amd) {
            define(function () {
                return functions;
            });
        } else if (typeof module !== 'undefined' && module !== null) {
            module.exports = functions;
        } else {
            globals.pubsub = functions;
        }
    }
}(this));


},{"check-types":4}]},{},[1])
;